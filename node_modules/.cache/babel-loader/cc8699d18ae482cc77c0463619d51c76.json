{"ast":null,"code":"// Simple React Validator v1.5.0 | Created By Dockwa | MIT License | 2017 - Present\n!function (e, t) {\n  \"function\" == typeof define && define.amd ? define([\"react\"], t) : \"object\" == typeof exports ? module.exports = t(require(\"react\")) : e.SimpleReactValidator = t(e.React);\n}(this, function (s) {\n  \"use strict\";\n\n  function f(e, t) {\n    return function (e) {\n      if (Array.isArray(e)) return e;\n    }(e) || function (e, t) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n      var r = [],\n          n = !0,\n          s = !1,\n          a = void 0;\n\n      try {\n        for (var i, u = e[Symbol.iterator](); !(n = (i = u.next()).done) && (r.push(i.value), !t || r.length !== t); n = !0);\n      } catch (e) {\n        s = !0, a = e;\n      } finally {\n        try {\n          n || null == u.return || u.return();\n        } finally {\n          if (s) throw a;\n        }\n      }\n\n      return r;\n    }(e, t) || o(e, t) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function p(e, t) {\n    var r;\n\n    if (\"undefined\" == typeof Symbol || null == e[Symbol.iterator]) {\n      if (Array.isArray(e) || (r = o(e)) || t && e && \"number\" == typeof e.length) {\n        r && (e = r);\n\n        var n = 0,\n            s = function () {};\n\n        return {\n          s: s,\n          n: function () {\n            return n >= e.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: e[n++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: s\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var a,\n        i = !0,\n        u = !1;\n    return {\n      s: function () {\n        r = e[Symbol.iterator]();\n      },\n      n: function () {\n        var e = r.next();\n        return i = e.done, e;\n      },\n      e: function (e) {\n        u = !0, a = e;\n      },\n      f: function () {\n        try {\n          i || null == r.return || r.return();\n        } finally {\n          if (u) throw a;\n        }\n      }\n    };\n  }\n\n  function o(e, t) {\n    if (e) {\n      if (\"string\" == typeof e) return n(e, t);\n      var r = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === r && e.constructor && (r = e.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(e) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(e, t) : void 0;\n    }\n  }\n\n  function n(e, t) {\n    (null == t || t > e.length) && (t = e.length);\n\n    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];\n\n    return n;\n  }\n\n  function a(e) {\n    return (a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    })(e);\n  }\n\n  function i(t, e) {\n    var r = Object.keys(t);\n\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(t);\n      e && (n = n.filter(function (e) {\n        return Object.getOwnPropertyDescriptor(t, e).enumerable;\n      })), r.push.apply(r, n);\n    }\n\n    return r;\n  }\n\n  function d(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? i(Object(r), !0).forEach(function (e) {\n        l(t, e, r[e]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach(function (e) {\n        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n      });\n    }\n\n    return t;\n  }\n\n  function u(e, t) {\n    for (var r = 0; r < t.length; r++) {\n      var n = t[r];\n      n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n    }\n  }\n\n  function e(e, t, r) {\n    return t && u(e.prototype, t), r && u(e, r), e;\n  }\n\n  function l(e, t, r) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = r, e;\n  }\n\n  var t = function () {\n    function n() {\n      var r = this,\n          e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, n), l(this, \"showMessageFor\", function (e) {\n        r.visibleFields.includes(e) || r.visibleFields.push(e), r.helpers.forceUpdateIfNeeded();\n      }), l(this, \"hideMessageFor\", function (e) {\n        var t = r.visibleFields.indexOf(e);\n        -1 < t && r.visibleFields.splice(t, 1), r.helpers.forceUpdateIfNeeded();\n      }), l(this, \"helpers\", {\n        parent: this,\n        passes: function (e, t, r, n) {\n          return n.hasOwnProperty(e) ? !(this.isRequired(e, n) || !this.isBlank(t)) || !1 !== n[e].rule(t, r, this.parent) : (console.error(\"Rule Not Found: There is no rule with the name \".concat(e, \".\")), !0);\n        },\n        isRequired: function (e, t) {\n          return t[e].hasOwnProperty(\"required\") && t[e].required;\n        },\n        isBlank: function (e) {\n          return null == e || this.testRegex(e, /^[\\s]*$/);\n        },\n        normalizeValues: function (e, t) {\n          return [this.valueOrEmptyString(e), this.getValidation(t), this.getOptions(t)];\n        },\n        getValidation: function (e) {\n          return e === Object(e) && Object.keys(e).length ? Object.keys(e)[0] : e.split(\":\")[0];\n        },\n        getOptions: function (e) {\n          if (e === Object(e) && Object.values(e).length) {\n            var t = Object.values(e)[0];\n            return Array.isArray(t) ? t : [t];\n          }\n\n          return 1 < (t = e.split(\":\")).length ? t[1].split(\",\") : [];\n        },\n        valueOrEmptyString: function (e) {\n          return null == e ? \"\" : e;\n        },\n        toSentence: function (e) {\n          return e.slice(0, -2).join(\", \") + (e.slice(0, -2).length ? \", \" : \"\") + e.slice(-2).join(2 < e.length ? \", or \" : \" or \");\n        },\n        testRegex: function (e, t) {\n          return null !== e.toString().match(t);\n        },\n        forceUpdateIfNeeded: function () {\n          this.parent.autoForceUpdate && this.parent.autoForceUpdate.forceUpdate();\n        },\n        message: function (e, t, r, n) {\n          r.messages = r.messages || {};\n          var s = r.messages[e] || r.messages.default || this.parent.messages[e] || this.parent.messages.default || n[e].message;\n          return s.replace(\":attribute\", this.humanizeFieldName(t));\n        },\n        humanizeFieldName: function (e) {\n          return e.replace(/([A-Z])/g, \" $1\").replace(/_/g, \" \").toLowerCase();\n        },\n        element: function (e, t) {\n          var r = t.element || this.parent.element;\n          return r(e, t.className);\n        },\n        momentInstalled: function () {\n          return !(!window || !window.moment) || (console.warn(\"Date validators require using momentjs https://momentjs.com and moment objects.\"), !1);\n        },\n        size: function (e, t) {\n          return \"string\" === t || void 0 === t || \"array\" === t ? e.length : \"num\" === t ? parseFloat(e) : void 0;\n        },\n        sizeText: function (e) {\n          return \"string\" === e || void 0 === e ? \" characters\" : \"array\" === e ? \" elements\" : \"\";\n        }\n      }), this.fields = {}, this.visibleFields = [], this.errorMessages = {}, this.messagesShown = !1, this.rules = d({\n        accepted: {\n          message: \"The :attribute must be accepted.\",\n          rule: function (e) {\n            return !0 === e;\n          },\n          required: !0\n        },\n        after: {\n          message: \"The :attribute must be after :date.\",\n          rule: function (e, t) {\n            return r.helpers.momentInstalled() && moment.isMoment(e) && e.isAfter(t[0], \"day\");\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":date\", t[0].format(\"MM/DD/YYYY\"));\n          }\n        },\n        after_or_equal: {\n          message: \"The :attribute must be after or on :date.\",\n          rule: function (e, t) {\n            return r.helpers.momentInstalled() && moment.isMoment(e) && e.isSameOrAfter(t[0], \"day\");\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":date\", t[0].format(\"MM/DD/YYYY\"));\n          }\n        },\n        alpha: {\n          message: \"The :attribute may only contain letters.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z]*$/i);\n          }\n        },\n        alpha_space: {\n          message: \"The :attribute may only contain letters and spaces.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z\\s]*$/i);\n          }\n        },\n        alpha_num: {\n          message: \"The :attribute may only contain letters and numbers.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z0-9]*$/i);\n          }\n        },\n        alpha_num_space: {\n          message: \"The :attribute may only contain letters, numbers, and spaces.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z0-9\\s]*$/i);\n          }\n        },\n        alpha_num_dash: {\n          message: \"The :attribute may only contain letters, numbers, and dashes.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z0-9_-]*$/i);\n          }\n        },\n        alpha_num_dash_space: {\n          message: \"The :attribute may only contain letters, numbers, dashes, and spaces.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z0-9_-\\s]*$/i);\n          }\n        },\n        array: {\n          message: \"The :attribute must be an array.\",\n          rule: function (e) {\n            return Array.isArray(e);\n          }\n        },\n        before: {\n          message: \"The :attribute must be before :date.\",\n          rule: function (e, t) {\n            return r.helpers.momentInstalled() && moment.isMoment(e) && e.isBefore(t[0], \"day\");\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":date\", t[0].format(\"MM/DD/YYYY\"));\n          }\n        },\n        before_or_equal: {\n          message: \"The :attribute must be before or on :date.\",\n          rule: function (e, t) {\n            return r.helpers.momentInstalled() && moment.isMoment(e) && e.isSameOrBefore(t[0], \"day\");\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":date\", t[0].format(\"MM/DD/YYYY\"));\n          }\n        },\n        between: {\n          message: \"The :attribute must be between :min and :max:type.\",\n          rule: function (e, t) {\n            return r.helpers.size(e, t[2]) >= parseFloat(t[0]) && r.helpers.size(e, t[2]) <= parseFloat(t[1]);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":min\", t[0]).replace(\":max\", t[1]).replace(\":type\", r.helpers.sizeText(t[2]));\n          }\n        },\n        boolean: {\n          message: \"The :attribute must be a boolean.\",\n          rule: function (e) {\n            return !1 === e || !0 === e;\n          }\n        },\n        card_exp: {\n          message: \"The :attribute must be a valid expiration date.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^(([0]?[1-9]{1})|([1]{1}[0-2]{1}))\\s?\\/\\s?(\\d{2}|\\d{4})$/);\n          }\n        },\n        card_num: {\n          message: \"The :attribute must be a valid credit card number.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^\\d{4}\\s?\\d{4,6}\\s?\\d{4,5}\\s?\\d{0,8}$/);\n          }\n        },\n        currency: {\n          message: \"The :attribute must be a valid currency.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^\\$?(\\d{1,3})(\\,?\\d{3})*\\.?\\d{0,2}$/);\n          }\n        },\n        date: {\n          message: \"The :attribute must be a date.\",\n          rule: function (e) {\n            return r.helpers.momentInstalled() && moment.isMoment(e);\n          }\n        },\n        date_equals: {\n          message: \"The :attribute must be on :date.\",\n          rule: function (e, t) {\n            return r.helpers.momentInstalled() && moment.isMoment(e) && e.isSame(t[0], \"day\");\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":date\", t[0].format(\"MM/DD/YYYY\"));\n          }\n        },\n        email: {\n          message: \"The :attribute must be a valid email address.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^[A-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i);\n          }\n        },\n        in: {\n          message: \"The selected :attribute must be :values.\",\n          rule: function (e, t) {\n            return t.includes(e);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":values\", r.helpers.toSentence(t));\n          }\n        },\n        integer: {\n          message: \"The :attribute must be an integer.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^\\d*$/);\n          }\n        },\n        max: {\n          message: \"The :attribute may not be greater than :max:type.\",\n          rule: function (e, t) {\n            return r.helpers.size(e, t[1]) <= parseFloat(t[0]);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":max\", t[0]).replace(\":type\", r.helpers.sizeText(t[1]));\n          }\n        },\n        min: {\n          message: \"The :attribute must be at least :min:type.\",\n          rule: function (e, t) {\n            return r.helpers.size(e, t[1]) >= parseFloat(t[0]);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":min\", t[0]).replace(\":type\", r.helpers.sizeText(t[1]));\n          }\n        },\n        not_in: {\n          message: \"The selected :attribute must not be :values.\",\n          rule: function (e, t) {\n            return !t.includes(e);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":values\", r.helpers.toSentence(t));\n          }\n        },\n        not_regex: {\n          message: \"The :attribute must not match the required pattern.\",\n          rule: function (e, t) {\n            return !r.helpers.testRegex(e, \"string\" == typeof t[0] || t[0] instanceof String ? new RegExp(t[0]) : t[0]);\n          }\n        },\n        numeric: {\n          message: \"The :attribute must be a number.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^\\-?\\d*\\.?\\d+$/);\n          }\n        },\n        phone: {\n          message: \"The :attribute must be a valid phone number.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^(\\+?\\d{0,4})?\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{4}\\)?)$/) && !r.helpers.testRegex(e, /^\\b(\\d)\\1{8,}\\b$/);\n          }\n        },\n        regex: {\n          message: \"The :attribute must match the required pattern.\",\n          rule: function (e, t) {\n            return r.helpers.testRegex(e, \"string\" == typeof t[0] || t[0] instanceof String ? new RegExp(t[0]) : t[0]);\n          }\n        },\n        required: {\n          message: \"The :attribute field is required.\",\n          rule: function (e) {\n            return !r.helpers.isBlank(e);\n          },\n          required: !0\n        },\n        size: {\n          message: \"The :attribute must be :size:type.\",\n          rule: function (e, t) {\n            return r.helpers.size(e, t[1]) == parseFloat(t[0]);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":size\", t[0]).replace(\":type\", r.helpers.sizeText(t[1]));\n          }\n        },\n        string: {\n          message: \"The :attribute must be a string.\",\n          rule: function (e) {\n            return a(e) === a(\"string\");\n          }\n        },\n        typeof: {\n          message: \"The :attribute is not the correct type of :type.\",\n          rule: function (e, t) {\n            return a(e) === a(t[0]);\n          },\n          messageReplace: function (e, t) {\n            return e.replace(\":type\", a(t[0]));\n          }\n        },\n        url: {\n          message: \"The :attribute must be a url.\",\n          rule: function (e) {\n            return r.helpers.testRegex(e, /^https?:\\/\\/[-a-z0-9@:%._\\+~#=]{1,256}\\.[a-z0-9()]{2,6}\\b([-a-z0-9()@:%_\\+.~#?&//=]*)$/i);\n          }\n        }\n      }, e.validators || {}), e.locale && !n.locales.hasOwnProperty(e.locale) && console.warn(\"Locale not found! Make sure it is spelled correctly and the locale file is loaded.\");\n      var t = n.locales[e.locale] || {};\n      Object.keys(this.rules).forEach(function (e) {\n        r.rules[e].message = t[e] || r.rules[e].message;\n      }), this.messages = e.messages || {}, this.className = e.className, this.autoForceUpdate = e.autoForceUpdate || !1, !1 === e.element ? this.element = function (e) {\n        return e;\n      } : e.hasOwnProperty(\"element\") ? this.element = e.element : \"object\" === (\"undefined\" == typeof navigator ? \"undefined\" : a(navigator)) && \"ReactNative\" === navigator.product ? this.element = function (e) {\n        return e;\n      } : this.element = function (e, t) {\n        return s.createElement(\"div\", {\n          className: t || r.className || \"srv-validation-message\"\n        }, e);\n      };\n    }\n\n    return e(n, null, [{\n      key: \"addLocale\",\n      value: function (e, t) {\n        this.locales[e] = t;\n      }\n    }]), e(n, [{\n      key: \"getErrorMessages\",\n      value: function () {\n        return this.errorMessages;\n      }\n    }, {\n      key: \"showMessages\",\n      value: function () {\n        this.messagesShown = !0, this.helpers.forceUpdateIfNeeded();\n      }\n    }, {\n      key: \"hideMessages\",\n      value: function () {\n        this.messagesShown = !1, this.helpers.forceUpdateIfNeeded();\n      }\n    }, {\n      key: \"allValid\",\n      value: function () {\n        for (var e in this.fields) if (!1 === this.fieldValid(e)) return !1;\n\n        return !0;\n      }\n    }, {\n      key: \"fieldValid\",\n      value: function (e) {\n        return this.fields.hasOwnProperty(e) && !0 === this.fields[e];\n      }\n    }, {\n      key: \"purgeFields\",\n      value: function () {\n        this.fields = {}, this.errorMessages = {};\n      }\n    }, {\n      key: \"messageWhenPresent\",\n      value: function (e) {\n        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};\n        if (!this.helpers.isBlank(e) && this.messagesShown) return this.helpers.element(e, t);\n      }\n    }, {\n      key: \"messageAlways\",\n      value: function (e, t) {\n        var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};\n        if (console.warn(\"The messageAlways() method is deprecated in SimpleReactValidator. Please see the documentation and switch to the messageWhenPresent() method.\"), t && this.messagesShown) return this.helpers.element(t, r);\n      }\n    }, {\n      key: \"check\",\n      value: function (e, t) {\n        var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};\n        Array.isArray(t) || (t = t.split(\"|\"));\n        var n,\n            s = r.validators ? d(d({}, this.rules), r.validators) : this.rules,\n            a = p(t);\n\n        try {\n          for (a.s(); !(n = a.n()).done;) {\n            var i = n.value,\n                u = f(this.helpers.normalizeValues(e, i), 3),\n                o = u[0],\n                l = u[1],\n                c = u[2];\n            if (!this.helpers.passes(l, o, c, s)) return !1;\n          }\n        } catch (e) {\n          a.e(e);\n        } finally {\n          a.f();\n        }\n\n        return !0;\n      }\n    }, {\n      key: \"message\",\n      value: function (e, t, r) {\n        var n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};\n        this.errorMessages[e] = null, this.fields[e] = !0, Array.isArray(r) || (r = r.split(\"|\"));\n        var s,\n            a = n.validators ? d(d({}, this.rules), n.validators) : this.rules,\n            i = p(r);\n\n        try {\n          for (i.s(); !(s = i.n()).done;) {\n            var u = s.value,\n                o = f(this.helpers.normalizeValues(t, u), 3),\n                l = o[0],\n                c = o[1],\n                m = o[2];\n\n            if (!this.helpers.passes(c, l, m, a)) {\n              this.fields[e] = !1;\n              var h = this.helpers.message(c, e, n, a);\n              if (0 < m.length && a[c].hasOwnProperty(\"messageReplace\") && (h = a[c].messageReplace(h, m)), this.errorMessages[e] = h, this.messagesShown || this.visibleFields.includes(e)) return this.helpers.element(h, n);\n            }\n          }\n        } catch (e) {\n          i.e(e);\n        } finally {\n          i.f();\n        }\n      }\n    }]), n;\n  }();\n\n  return l(t, \"version\", \"1.5.0\"), l(t, \"locales\", {\n    en: {}\n  }), t;\n});","map":null,"metadata":{},"sourceType":"script"}